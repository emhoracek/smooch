# Contents

  * [Install](#install)
  * [Run](#run)
  * [Build](#build)
  * [A tour of the directory](#a-tour-of-the-directory)
  * [How it works](#how-it-works)

# Install

First, [install node.js](https://nodejs.org/en/)

Then navigate to Smooch's root directory and run `npm install` to install the dev dependencies: Parcel and ESlint. There
are no non-dev dependencies currently - Smooch is just vanilla JS. Parcel is used to bundle and minify the JS. ESLint is to
make sure all contributors use the same code style.

# Run

Run `npm start` in the root directory to run the development server.
It will hot-reload with any changes you make.

# Build

Run `npm run build` to put the finished JavaScript in the `docs` and in the Haskell app's static directory. 
GitHub Pages automatically serves the files in the `docs` directory on the [Smooch demo page](https://emhoracek.github.io/smooch/).

# A tour of the directory

The `javascript` directory contains some HTML, a CSS file, and a few JavaScript files.

## `index.html`

This is the entrypoint of the appplication. It lists several different KiSS
dolls, the sources of which are in the `example-sets` directory.

## `example-sets`

This directory holds several KiSS dolls. Each doll has its own
directory with the following files:

* `index.html` - The page where you can view the doll.
* `setdata.js` - The data for the doll (see below for more detail).
* Many PNG image files.

### THe JavaScript

## `doll.js`

This is the main JavaScript file. It creates a `KiSSDoll` from the
`kissJSON` for a particular doll and sets up the drag-and-drop. It also
displays the loading screen.

## `kissDoll.js`

The `KiSSDoll` class with all the data for the doll.

## `kissObject.js`

Instances of the `KiSSObject` class represent a single KiSS "object"
such as a piece of clothing or a base doll. An object can contain
multiple cels (as in a coat with a front and a back).

## kissCel.js

Instances of the `KiSSCel` class represent a single "cel", or an
image of an item or part of an item.

## setdata.js

Each doll has this "script" which is just one variable declaration
(`kissJson`) assigned to some JSON representing the KiSS doll set's
 configuration, generated by the Haskell side of the app.

Here's JSON for a set with one object:

```(json)
{
  // the size of the play area
  "window_size": [
    700,
    430
  ],
  // a cel has a palette for the cel, the sets the cel
  // is visible in, a "fix" value indicating how many
  // time you need to click the cel before you can
  // drag it (usually 0 for clothes, a large number for
  // the body), a name, a "mark" (object ID), and how 
  // transparent the cel should be.
  cels: [
    {
      palette: 0,
      mark: 1,
      offset: { x: 10, y: 12 },
      alpha: 0,
      name: "doll",
      fix: 4000,
      sets: [0, 1, 2, 3, 4, 5, 6],
    }
  ],
  // These are the colors of the outside of the playarea and 
  // the playarea itself.
  "border": "#6570bd",
  "background": "#6570bd",
  // Finally we have a list of up to nine sets of clothing. 
  // Each set has a palette and the positions of each object 
  // in the doll from 0 to the highest object "mark" or ID. Since 
  // the highest in this doll is "1", there are two positions 
  // listed. If there's no object with a given index mark, the item 
  // at that index is { x: 0, y: 0 }.
  "positions": [
    {
      "palette": 0,
      "positions": [
        { x: 0, y: 0 },
        { x: 113, y: 157 }
      ]
    }
  ]
}
```

# How it works

## the ghost canvas

I'm using a game coding technique called a "ghost buffer" to detect
what images are being clicked on.

If you load a doll and right click and inspect the DOM, you'll see there's a
undisplayed second canvas besides the one that you can see and interact with.
That's the ghost canvas. If you remove the `display: none` from the CSS, you'll
be able to see it -- it's right below the actual canvas. All the images on the 
real canvas are also drawn on the ghost canvas, but
instead of the original colors, each item is a subtly different color.

When a player clicks on the real canvas, the JavaScript looks up the
corresponding pixel on the ghost canvas. Each color on the ghost canvas maps to
one cel in the set, so the script knows which cel you clicked!
