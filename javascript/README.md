# Contents

  * [Install](#install)
  * [Run](#run)
  * [Build](#build)
  * [A tour of the directory](#a-tour-of-the-directory)
  * [How it works](#how-it-works)

# Install

First, [install node.js](https://nodejs.org/en/)

Then navigate to this directory (`javascript`) and run `npm install` to install the dev dependencies: Parcel and ESlint. There
are no non-dev dependencies currently - Smooch is just vanilla JS. Parcel is used to bundle and minify the JS. ESLint is to
make sure all contributors use the same code style.

# Run

Run `npm start` to run the development server. It will hot-reload
with any changes you make.

# Build

Run `npm run build` to put the finished JavaScript on the [Smooch demo page](https://emhoracek.github.io/smooch/)

# A tour of the directory

The smooch demo contains some HTML, a CSS file, and a few JavaScript files.

## `index.html`

This is the entrypoint of the appplication. It lists several different KiSS
dolls, the sources of which are in the `example-sets` directory.

## `example-sets`

This directory holds several KiSS dolls. Each doll has its own
directory with the following files:

* `index.html` - The page where you can view the doll.
* `setdata.js` - The data for the doll (see below for more detail).
* Many PNG image files.

### THe JavaScript

## `doll.js`

This is the main JavaScript file. It creates a `KiSSDoll` from the
`kissJSON` for a particular doll and sets up the drag-and-drop. It also
displays the loading screen.

## `kissDoll.js`

The `KiSSDoll` class with all the data for the doll.

## `kissObject.js`

Instances of the `KiSSObject` class represent a single KiSS "object"
such as a piece of clothing or a base doll. An object can contain
multiple cels (as in a coat with a front and a back).

## kissCel.js

Instances of the `KiSSCel` class represent a single "cel", or an
image of an item or part of an item.

## setdata.js

Each doll has this "script" which is just one variable declaration
(`kissJson`) assigned to some JSON representing the KiSS doll set's
 configuration, generated by the Haskell side of the app.

Here's JSON for a set with one object:

```(json)
{
  // the size of the play area
  "window_size": [
    700,
    430
  ],
  "objs": [
  // an object has an id number, a list of cels, and a
  // list of positions
    {
      "id": 0,
      "cels": [
      // a cel has a palette for the cel, the sets the cel
      // is visible in, a "fix" value indicating how many
      // time you need to click the cel before you can
      // drag it (usually 0 for clothes, a large number for
      // the body), a name, and how transparent it should be.
        {
          "palette": 0,
          "sets": [ 1,2,3,4,5,6,7,8,9 ]
          ],
          "fix": 4000,
          "name": "aurora",
          "alpha": 0
        }
      ],
      "positions": [
        {
          "y": 0,
          "x": 0
        },
        {
          "y": 67,
          "x": 283
        },
        {
          "y": 67,
          "x": 283
        },
        {
          "y": 67,
          "x": 283
        },
        {
          "y": 67,
          "x": 283
        },
        {
          "y": 67,
          "x": 283
        },
        {
          "y": 67,
          "x": 283
        },
        {
          "y": 67,
          "x": 283
        },
        {
          "y": 67,
          "x": 283
        },
        {
          "y": 67,
          "x": 283
        }
      ]
    }
  ],
  // The cels are listed again in order of appearance in the CNF file. This
  // allows us to display them in correct top-to-bottom order.
  "cels": [
    {
      "palette": 0,
      "sets": [ 1,2,3,4,5,6,7,8,9 ]
      ],
      "fix": 4000,
      "name": "aurora",
      "alpha": 0
    }
  ]
}
```

# How it works

## the ghost canvas

I'm using a game coding technique called a "ghost buffer" to detect
what images are being clicked on.

If you load a doll and right click and inspect the DOM, you'll see there's a
undisplayed second canvas besides the one that you can see and interact with.
That's the ghost canvas. If you remove the `display: none` from the CSS, you'll
be able to see it -- it's right below the actual canvas and has a bright blue
background. Each item in the real canvas is also drawn on the ghost canvas, but
in shades of black to red. Each item is a subtly different color.

When a player clicks on the real canvas, the JavaScript looks up the
corresponding pixel on the ghost canvas. Each color on the ghost canvas maps to
one object in the set, so the script knows which object you clicked!
